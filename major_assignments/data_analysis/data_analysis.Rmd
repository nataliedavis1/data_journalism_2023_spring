---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

```{r}
library(janitor)
library(tidyverse)
spotify_youtube <- read_csv("data/Spotify_Youtube.csv")%>%
clean_names()

spotify_youtube <- spotify_youtube %>%
  mutate(minute_run = duration_ms / 60000) 
```


```{r}

# Question 1. How does the amoint of energy within the music compare to the number of views the song has 

spotify_youtube %>%
  mutate(views_energy = energy / views) %>%
  arrange(desc(views_energy))

#The problem here is that some songs have only 2 views and some have thousands of views, is there a better way to compare here? **

 correlation <- cor(spotify_youtube$energy, spotify_youtube$views, na.rm=TRUE)
mutate(correlation = cor (energy, views))
print(correlation)
```



```{r}
#Question 2: Is there a connection between the length of the song and the valence (mood) of the song?
spotify_youtube <- spotify_youtube %>%
  mutate(minute_run = duration_ms / 60000) %>%
  mutate(minute_val_ratio = valence/minute_run) %>%
  arrange(desc(minute_val_ratio))

#Note: We tried to compare the valence to the minute run but weren’t sure if the number was an accurate representation because the shortest songs were only appearing at the top and some songs did not have valence. We are not sure if there is a better way to find this comparison.  


```





```{r}
# Question 3. What key is most frequent within the top 20 most streamed songs? 
top20<- spotify_youtube %>%
  arrange (desc(stream)) %>%
head (25)
  top20_cleaned <- top20[c (-5, -8, -11, -13, -23), ] 
  
top20_key <- top20_cleaned%>%
  group_by(key)%>%
  summarise(total_key = n()) %>%
  arrange (desc(total_key))

# The most common keys are C# (1), G (7) and D (2). These keys occur 5, 3 and 2 times respectively. Since the C# key occurs five times, our major finding is that the C# key is occuring about 25% of the time within the top 20 most streamed songs. 
```

```{r}
# Question 4. What level of loudness is the most frequent among the top 20 streamed songs? 

top20_loudness <- top20_cleaned%>%
  group_by(loudness)%>%
  summarise(total_loudness = n()) %>%
  arrange (desc(total_loudness))

loudness_rounded <- top20_cleaned %>%
  mutate( loudness_rounded = round(loudness, 0)) %>%
    group_by(loudness_rounded)%>%
  summarise(total_loudness_rounded = n()) %>%
  arrange (desc(total_loudness_rounded))

# The most common levels of loudness among the top 20 streamed songs are -6, -7 and -5, which occurred 8, 4 and 2 times within the data set respectively. Since 8 out of the 20 most streamed songs have a loudness of -6, this occurs about 40% of the time. We could not figure out how loud that actually is because when we researched decibels the meausuring unit was a completely different scale then our data set had it as. 
```



```{r}
# Question 5: Of the top 20 most streamed songs, which song has the highest like to view ratio?

top20_liketoview <- top20_cleaned %>%
  mutate(like_views = likes / views * 100) %>%
  arrange(desc(like_views))

# The songs that have the highest like to view ratio are Heat Waves by Glass Animals and Stay by The Kid Laroi (feat. Justin Bieber), these songs both have approximately a 1.49 % like to view ratio. This means that about 1.49% of all the people who viewed their respective music videos on Youtube gave it a like. 

```

####

1. Loads and cleans the core data set to prepare for analysis.

We used the cleannames() function to get rid of unnecessary spaces in the column names. 


 2. Shows basic exploratory analysis to demonstrate an understanding of the dataset, including the number of rows and columns, any obvious limitations or flaws and any reasons why it might not be able to answer the questions you've posted last week. 


In this dataset there are 20,718 rows (different songs) with 21 columns (mostly different categories to break down the songs, though some are links). There aren’t any obvious flaws that stand out to us at the moment. 

A big limitation is that the data does not tell us the date that songs came out. This is important to know because it could be unfair to compare a song that just came out to one that’s been out for years and the two are not actually equal. This data also doesn’t tell us the peak height that a song reached on the Hot 100 Billboard charts which could be interesting to be aware of. It would be a bit hard to define what “popular” means outside of this metric, but for our case we will try to find a dataset that we think fits it to the best of our ability. 

3. Describe the limits of the data in terms of timeframe, what is and is not included and any codes or other information you'd need to find definitions for, and what you've done to better define it.

The data was collected Feb 7, 2023. So right off the bat any songs that were released after that are not on the list and any songs that gained popularity after that are not reflected properly to the numbers of today.. For the most part all the data is understandable and we wouldn’t need to search for the definitions of it. The only term that I was unfamiliar with was “valence” but after a quick google search I learned that it means musical positiveness conveyed by a track.

####



Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file). 

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.



